# -*- coding: utf-8 -*-
"""numpy_pandas_introduction_day_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10FtZ8RM8RdMxYV5ELDYjh0rzDER3HyYm

# Introduction to Data Analysis with Python


<img src="https://www.python.org/static/img/python-logo.png" alt="yogen" style="width: 200px; float: right;"/>
<br>
<br>
<br>

# Objectives

* Handle linear algebra using `numpy`

* Handle tabular data with `pandas`

# The Python scientific stack: SciPy

Python Main Data Libraries

NumPy: Base N-dimensional array package

SciPy library: Fundamental library for scientific computing

Matplotlib: Comprehensive 2D Plotting

IPython: Enhanced Interactive Console

Sympy: Symbolic mathematics

pandas: Data structures & analysis
"""

import numpy as np

import pandas as pd

import matplotlib.pyplot as plt

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

"""## `matplotlib`"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib

#matplotlib.style.use('ggplot')
# %matplotlib inline

import matplotlib as plt2



plt.plot([1,2,3], [4,5,7]);

X = np.linspace(-np.pi, np.pi, 25)
C = np.cos(X)
S = np.sin(X)
plt.plot(X,S,"r.-");
plt.plot(X,C,"b.-");
plt.grid(True)
#plt.show()

plt.scatter(X, C, c='r');
plt.scatter(X, S,c='b');

"""## `numpy`

Base N-dimensional array package. We can use it to perform array operations. Its arrays are typed and can have any shape and dimension we want.
"""

np.version.version

a_list = [1,2.0,3.1,4.2,-1,8.92]

type(a_list)

a_list = [1, 2.0,3.1,4.2,-1,8.92]
a = np.array(a_list)
a.dtype

a.shape

a.ndim

ej = np.array( [ [1,2+1.j], [3,4]])

ej



a2 = np.array([[1,2,3],[4,5,6],[7,8,9],[10,11,12]])
print(a2)

print(a.shape, a2.shape)
print(a.size,a2.size)

"""There are a number of convenience functions to create particular special arrays."""

np.zeros((4,2))

np.ones((4,3))

np.ones_like(a2)

np.eye(4)

kk = np.empty((4,2))

kk

print(np.zeros(10))
print(np.ones((2,3)))
print(np.ones_like(a2))
print(np.eye(4))
print(np.empty((2,3,2)))

np.arange(1,20,2)

np.linspace(1,20,10)

print(np.arange(10))
print(np.arange( 10, 30, 5 ))
print(np.arange( 0, 2 * np.math.pi, 0.3 ))
print(np.linspace( 0, 2 * np.math.pi, 15 ))

"""A central advantage of numpy over regular python lists, apart from the many convenience functions, is speed."""

narray = np.arange(100000)
plist = range(100000)

import math

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# [math.sqrt(n) for n in plist]



# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# np.sqrt(narray)

np.arange(10000)
#.reshape(100,100)

np.arange(10000).reshape(100,100)

"""And arrays of random variables."""

help(np.random.randn)

np.random.randn(9).reshape(3,3)

np.random.randn(3,3)

np.random.rand(10,2)

"""#### Exercise 1

Create a sample of points that follow the equation $Y = AX + B$, where A = 2.5 and B = 20.

Now, plot it as either a cloud of points or a line.

Defining starting variables:
"""

n_elements = 100
A = 5.0
B = 20
origin_list = [0,10,-10]
X1 = np.random.rand(n_elements)
X2 = np.linspace(0,1,n_elements)
#plt.show()

"""Looping through my process:"""

for ori in origin_list:
    plt.plot(X1,2.5*X1+B+ori)
    #plt.plot(X2,A*X2+B,'r')

for slope in origin_list:
    plt.plot(X1,slope*X1+B)











X = np.random.rand(20)
Y = 2.5 * X + 20

plt.plot(X, Y)
plt.scatter(X, Y, c='blue')
plt.show()

"""#### Exercise 2

Represent the logistic, or sigmoid, function between -20 and 20. Remember its formula is:

$$\displaystyle S(x)={\frac {1}{1+e^{-x}}}={\frac {e^{x}}{e^{x}+1}}$$

_Hint_: you will need an X and a Y to plot against it. 

_Hint_: check out the function np.exp
"""

def sigmoid(X):
    return 1.0/(1.+np.exp(-X))

N = 100
L = 20
x = np.linspace(-L,L,N)
plt.plot(x,sigmoid(x),'b.')

"""###Exercise 3

Create a simple pre-processing routine for feeding a Neural Network called Multi-Layer Perceptron (MLP). You must read Mist images via Keras/Tensorflow and reshape them in order to adapt them to the linear Input Layer of an MLP. If you will, display images with matplotlib. Finally, Normalize images with values within 0 and 1 for a better convergence of the Neural Network training. 

hint: download train and test data by means of load_data from keras.datasetws
"""

from keras.datasets import fashion_mnist, mnist
input_dim = 784
default_callbacks = []
random.seed(42)

#download mnist data and split into train and test sets
#(X_train, y_train), (X_test, y_test) = fashion_mnist.load_data()
(X_train, y_train), (X_test, y_test) = mnist.load_data()

for k in range(1):
    # Show the first image from the training set
    plt.imshow(X_train[k], cmap = 'gray')
    plt.savefig("first_fashion_mnist_train_image_"+str(k)+".jpg")
    print("First fashion mnist train image", y_train[0])
    plt.show(block = False)
    plt.pause(3)
    plt.close()

for k in range(1):
    # Show the first image from the test set
    plt.imshow(X_test[k], cmap = 'gray')
    plt.savefig("first_fashion_mnist_test_image"+str(k)+".jpg")
    print("First fashion mnist test image", y_test[0])
    plt.show(block = False)
    plt.pause(3)
    plt.close()
    
X_train = X_train.reshape(60000,784)                # linearization of image data (which is 2-dimensional originally) because our model is mlp, so accept only linear data, unlike convolutional networks
X_test = X_test.reshape(10000,784)

# Normalization (testare come senza normalizzazione converge molto tardi a 95% rispetto alla normalizzazione)
X_train = X_train / 255.0
X_test = X_test / 255.0